# aidev/schemas/__init__.py
from __future__ import annotations

"""
Central JSON Schema loader/registry for AI Dev Bot.
"""

from pathlib import Path
from functools import lru_cache
from typing import Any, Dict, List, Optional, Union, Tuple

import json

try:
    import jsonschema  # type: ignore[import]
except Exception:  # pragma: no cover - optional dependency
    jsonschema = None  # type: ignore[assignment]


JsonSchema = Dict[str, Any]
JsonLike = Any

# Directory containing the *.schema.json files
SCHEMAS_DIR = Path(__file__).resolve().parent

# Logical names -> filenames (relative to SCHEMAS_DIR)
_SCHEMA_FILES: Dict[str, str] = {
    # Core planning / edits
    "file_edit": "file_edit.schema.json",
    "targets": "targets.schema.json",
    "recommendations": "recommendations.schema.json",

    # Cards / summaries
    "cards": "cards.schema.json",
    "ai_summary": "ai_summary.schema.json",

    # Project lifecycle / orchestration
    "project_create": "project_create.schema.json",
    "project_create_request": "project_create_request.schema.json",
    "project_run_checks": "project_run_checks.schema.json",
    "project_select": "project_select.schema.json",
    "project_update_descriptions": "project_update_descriptions.schema.json",

    # Deep research artifacts (added for DeepResearchEngine)
    "research_plan": "research_plan.schema.json",
    "research_brief": "research_brief.schema.json",

    # Q&A mode
    "qa_answer": "qa_answer.schema.json",
}


class SchemaNotFoundError(RuntimeError):
    """Raised when a requested schema cannot be found on disk."""


class SchemaFormatError(RuntimeError):
    """Raised when a schema file exists but is not a JSON object."""


class SchemaValidationUnavailable(RuntimeError):
    """Raised when validation is requested but jsonschema is not installed."""


def _resolve_schema_path(name_or_filename: str) -> Path:
    if name_or_filename in _SCHEMA_FILES:
        filename = _SCHEMA_FILES[name_or_filename]
        return SCHEMAS_DIR / filename

    candidate = name_or_filename
    if not candidate.endswith(".json"):
        if not candidate.endswith(".schema"):
            candidate = f"{candidate}.schema.json"
        else:
            candidate = f"{candidate}.json"

    return SCHEMAS_DIR / candidate


@lru_cache(maxsize=None)
def load_schema(name_or_filename: str) -> JsonSchema:
    path = _resolve_schema_path(name_or_filename)
    if not path.exists():
        raise SchemaNotFoundError(
            f"Schema '{name_or_filename}' not found at {path}"
        )

    try:
        raw = json.loads(path.read_text(encoding="utf-8"))
    except Exception as exc:  # pragma: no cover - I/O/JSON corner cases
        raise SchemaFormatError(
            f"Failed to parse JSON for schema '{name_or_filename}' at {path}: {exc}"
        ) from exc

    if not isinstance(raw, dict):
        raise SchemaFormatError(
            f"Schema '{name_or_filename}' at {path} must be a JSON object, "
            f"got {type(raw).__name__}"
        )

    return raw


# ---------------------------------------------------------------------------
# Convenience accessors for core schemas
# ---------------------------------------------------------------------------


def file_edit_schema() -> JsonSchema:
    """
    Canonical schema describing a single file edit (aidev/schemas/file_edit.schema.json).

    This is the "one true" contract for code changes generated by the LLM.
    """
    return load_schema("file_edit")


def targets_schema() -> JsonSchema:
    """
    Canonical schema describing the target-selection envelope used when
    picking files for a recommendation (aidev/schemas/targets.schema.json).
    """
    return load_schema("targets")


def recommendations_schema() -> JsonSchema:
    """
    Canonical schema describing the top-level recommendations array
    (aidev/schemas/recommendations.schema.json).
    """
    return load_schema("recommendations")


def cards_schema() -> JsonSchema:
    """Schema for the cards index / card structures."""
    return load_schema("cards")


def ai_summary_schema() -> JsonSchema:
    """Schema for AI-generated summaries of files or resources."""
    return load_schema("ai_summary")


def project_create_schema() -> JsonSchema:
    """Schema for creating a new project run / configuration."""
    return load_schema("project_create")


def project_create_request_schema() -> JsonSchema:
    """Schema for project-create request payloads."""
    return load_schema("project_create_request")


def project_run_checks_schema() -> JsonSchema:
    """Schema describing the payload/results for running project checks."""
    return load_schema("project_run_checks")


def project_select_schema() -> JsonSchema:
    """Schema describing selection of a project/run from a list."""
    return load_schema("project_select")


def project_update_descriptions_schema() -> JsonSchema:
    """Schema describing updates to project/file descriptions."""
    return load_schema("project_update_descriptions")


def research_plan_schema() -> JsonSchema:
    """Schema for a ResearchPlan (aidev/schemas/research_plan.schema.json).

    Callers may also use load_schema("research_plan") interchangeably.
    """
    return load_schema("research_plan")


def research_brief_schema() -> JsonSchema:
    """Schema for a ResearchBrief (aidev/schemas/research_brief.schema.json).

    Callers may also use load_schema("research_brief") interchangeably.
    """
    return load_schema("research_brief")


def qa_answer_schema() -> JsonSchema:
    """Schema describing Q&A mode LLM answers."""
    return load_schema("qa_answer")


def analyze_plan_schema() -> JsonSchema:
    """
    Schema describing the analyze-plan envelope produced by analyze mode.

    Schema file: analyze_plan.schema.json
    """
    # Accept either logical name or explicit filename; load_schema will resolve.
    return load_schema("analyze_plan")


def self_review_schema() -> JsonSchema:
    """Schema describing self-review JSON output."""
    return load_schema("self_review")


def target_analysis_schema() -> JsonSchema:
    """Schema describing per-target analysis output."""
    return load_schema("target_analysis.schema.json")


# ---------------------------------------------------------------------------
# Validation helpers (optional jsonschema dependency)
# ---------------------------------------------------------------------------


def validate_instance(
    instance: JsonLike,
    schema: Optional[JsonSchema] = None,
    *,
    schema_name: Optional[str] = None,
) -> None:
    """
    Validate a JSON-like instance against a schema.

    Args:
        instance:
            The decoded JSON data to validate (dict, list, etc.).

        schema:
            The JSON Schema object to validate against. If omitted, you must
            provide `schema_name` to load a schema via `load_schema()`.

        schema_name:
            Logical schema name or filename to load via `load_schema()` if
            `schema` is not provided. For example: "file_edit", "targets",
            "recommendations", etc.

    Raises:
        SchemaValidationUnavailable  - if jsonschema is not installed.
        SchemaNotFoundError         - if schema_name is provided but not found.
        SchemaFormatError           - if schema_name is provided but is invalid.
        jsonschema.ValidationError  - if validation fails (when jsonschema is present).
    """
    if schema is None:
        if not schema_name:
            raise ValueError(
                "validate_instance() requires either `schema` or `schema_name`."
            )
        schema = load_schema(schema_name)

    if jsonschema is None:  # pragma: no cover - only when dependency missing
        raise SchemaValidationUnavailable(
            "jsonschema is not installed; cannot perform schema validation. "
            "Install it with `pip install jsonschema` or add it to your project "
            "dependencies."
        )

    jsonschema.validate(instance=instance, schema=schema)  # type: ignore[attr-defined]


NormalizedPath = List[Union[str, int]]


def _to_normalized_path(path: Any) -> NormalizedPath:
    """Convert jsonschema error paths to a stable list form."""
    try:
        return list(path)
    except Exception:  # pragma: no cover
        return []


def _error_sort_key(err: Dict[str, Any]) -> tuple:
    # Deterministic ordering: path as string tuple, then message.
    path = err.get("path") or []
    path_key = tuple(str(p) for p in path)
    return (path_key, str(err.get("message") or ""))


def _flatten_jsonschema_error(error: Any) -> List[Dict[str, Any]]:
    """Flatten jsonschema.ValidationError (including nested context) deterministically."""
    out: List[Dict[str, Any]] = []

    def visit(e: Any) -> None:
        out.append(
            {
                "message": str(getattr(e, "message", e)),
                "path": _to_normalized_path(getattr(e, "path", [])),
                "schema_path": _to_normalized_path(getattr(e, "schema_path", [])),
                "validator": getattr(e, "validator", None),
            }
        )
        # e.context contains nested/aggregate errors for things like oneOf/anyOf.
        for child in sorted(
            list(getattr(e, "context", []) or []),
            key=lambda ce: (
                tuple(str(p) for p in _to_normalized_path(getattr(ce, "path", []))),
                str(getattr(ce, "message", "")),
            ),
        ):
            visit(child)

    visit(error)
    out.sort(key=_error_sort_key)
    return out


def validate_instance_safe(
    instance: JsonLike,
    schema: Optional[JsonSchema] = None,
    *,
    schema_name: Optional[str] = None,
) -> Dict[str, Any]:
    """Returns {'valid': True} or {'valid': False, 'errors': [...]}. Never raises jsonschema exceptions; reports jsonschema missing as an error payload."""
    try:
        if schema is None:
            if not schema_name:
                raise ValueError(
                    "validate_instance_safe() requires either `schema` or `schema_name`."
                )
            schema = load_schema(schema_name)

        if jsonschema is None:
            return {
                "valid": False,
                "errors": [
                    {
                        "message": "schema validation unavailable: jsonschema not installed",
                        "path": [],
                        "schema_path": [],
                        "validator": None,
                    }
                ],
            }

        try:
            jsonschema.validate(instance=instance, schema=schema)  # type: ignore[attr-defined]
            return {"valid": True}
        except Exception as exc:
            # Best-effort normalization when jsonschema is present.
            if jsonschema is not None and isinstance(
                exc, getattr(jsonschema, "ValidationError", Exception)
            ):
                return {"valid": False, "errors": _flatten_jsonschema_error(exc)}

            # Non-validation errors (should be rare): still return normalized payload.
            return {
                "valid": False,
                "errors": [
                    {
                        "message": str(exc),
                        "path": [],
                        "schema_path": [],
                        "validator": None,
                    }
                ],
            }

    except Exception as exc:
        # Do not leak schema loader/format errors as exceptions to safe callers.
        return {
            "valid": False,
            "errors": [
                {
                    "message": str(exc),
                    "path": [],
                    "schema_path": [],
                    "validator": None,
                }
            ],
        }


def validate_research_plan(instance: JsonLike) -> Dict[str, Any]:
    """Wrapper that calls validate_instance_safe(..., schema_name='research_plan').

    Public return contract (dict-safe):
        - On success: {'valid': True}
        - On failure: {'valid': False, 'errors': [ ... ]}

    This function intentionally does NOT raise jsonschema.ValidationError; callers
    that prefer exceptions or tuple-style results can use the compatibility
    helpers provided below: `validate_research_plan_tuple`.
    """
    return validate_instance_safe(instance, schema_name="research_plan")


def validate_research_plan_tuple(instance: JsonLike) -> Tuple[bool, List[Dict[str, Any]]]:
    """Compatibility wrapper around validate_research_plan.

    Returns a (valid, errors) tuple where `errors` is an empty list on success
    or the list of normalized error dicts on failure. This is a thin helper for
    callers that expect a tuple-returning API instead of the dict-safe API.
    """
    res = validate_research_plan(instance)
    if res.get("valid"):
        return True, []
    return False, list(res.get("errors") or [])


def validate_analyze_plan(instance: JsonLike) -> Dict[str, Any]:
    """Wrapper that calls validate_instance_safe(..., schema_name='analyze_plan').

    Public return contract (dict-safe):
        - On success: {'valid': True}
        - On failure: {'valid': False, 'errors': [ ... ]}

    This mirrors the research_plan helpers and returns a normalized dict-safe
    payload suitable for SSE/UI payloads.
    """
    return validate_instance_safe(instance, schema_name="analyze_plan")


def validate_analyze_plan_tuple(instance: JsonLike) -> Tuple[bool, List[Dict[str, Any]]]:
    """Compatibility wrapper around validate_analyze_plan.

    Returns a (valid, errors) tuple where `errors` is an empty list on success
    or the list of normalized error dicts on failure.
    """
    res = validate_analyze_plan(instance)
    if res.get("valid"):
        return True, []
    return False, list(res.get("errors") or [])


def validate_analyze_plan_raise(instance: JsonLike) -> None:
    """Exception-raising validator for analyze_plan schema."""
    validate_instance(instance, schema_name="analyze_plan")


def validate_schema(name: str, payload: JsonLike) -> Dict[str, Any]:
    """Generic, deterministic schema validator used by other modules.

    Args:
        name: Logical schema name or filename (e.g. 'analyze_plan' or 'analyze_plan.schema.json').
        payload: The JSON-like payload to validate.

    Returns:
        A dict-safe result: {'valid': True} on success, or {'valid': False, 'errors': [...]} on failure.

    This helper never raises jsonschema.ValidationError; loader/format/validation
    issues are returned as normalized diagnostics. Callers that prefer an
    exception-raising API can use validate_instance(...) directly.
    """
    return validate_instance_safe(payload, schema_name=name)


def validate_payload(name: str, payload: JsonLike) -> Dict[str, Any]:
    """Alias for validate_schema for callers expecting `validate_payload` name."""
    return validate_schema(name, payload)


def validate_targets_envelope(envelope: JsonLike) -> None:
    """
    Validate a TargetsEnvelope instance against the JSON Schema *and*
    enforce additional cross-field invariants that JSON Schema alone
    cannot easily express.

    Raises:
        SchemaValidationUnavailable  - if jsonschema is not installed.
        SchemaNotFoundError         - if the 'targets' schema cannot be loaded.
        SchemaFormatError           - if the 'targets' schema is invalid.
        jsonschema.ValidationError  - if schema-level validation fails.
        ValueError                  - if cross-field invariants are violated.
    """
    # 1) Schema-level validation (shape, types, enums, etc.)
    validate_instance(envelope, schema_name="targets")

    # Be tolerant of missing keys here, but we expect schema to require them.
    selected_files = envelope.get("selected_files", [])
    preview = envelope.get("llm_payload_preview", [])
    targets = envelope.get("targets", [])

    # 2) Invariant: selected_files and llm_payload_preview must have same length.
    if len(selected_files) != len(preview):
        raise ValueError(
            "TargetsEnvelope: 'selected_files' and 'llm_payload_preview' "
            "must have the same length."
        )

    # 3) Invariant: paths in selected_files and llm_payload_preview must match 1:1.
    preview_paths = {item.get("path") for item in preview}
    if set(selected_files) != preview_paths:
        raise ValueError(
            "TargetsEnvelope: 'selected_files' must match the set of "
            "'llm_payload_preview[*].path' values 1:1."
        )

    # 4) Invariant: each llm_payload_preview item must have exactly one of content or content_excerpt non-null.
    for item in preview:
        content = item.get("content")
        excerpt = item.get("content_excerpt")

        # Normalize types: schema already enforces string/null, but we just care about "present and non-null".
        has_content = content is not None
        has_excerpt = excerpt is not None

        if not has_content and not has_excerpt:
            raise ValueError(
                "TargetsEnvelope: each llm_payload_preview item must have "
                "either 'content' or 'content_excerpt' set (non-null)."
            )
        if has_content and has_excerpt:
            raise ValueError(
                "TargetsEnvelope: each llm_payload_preview item must have "
                "exactly one of 'content' or 'content_excerpt' set, not both."
            )

    # 5) Invariants relating targets <-> selected_files:
    #    - For edit/rename/delete of an existing file, path MUST be in selected_files.
    #    - For create, path MUST NOT be in selected_files.
    selected_set = set(selected_files)
    for target in targets:
        path = target.get("path")
        intent = target.get("intent")

        if intent in ("edit", "rename", "delete"):
            if path not in selected_set:
                raise ValueError(
                    f"TargetsEnvelope: target path '{path}' with intent '{intent}' "
                    "must appear in 'selected_files'."
                )
        elif intent == "create":
            if path in selected_set:
                raise ValueError(
                    f"TargetsEnvelope: target path '{path}' with intent 'create' "
                    "must NOT appear in 'selected_files'."
                )


__all__ = [
    "JsonSchema",
    "JsonLike",
    "SCHEMAS_DIR",
    "SchemaNotFoundError",
    "SchemaFormatError",
    "SchemaValidationUnavailable",
    "load_schema",

    # schema accessors
    "file_edit_schema",
    "targets_schema",
    "recommendations_schema",
    "cards_schema",
    "ai_summary_schema",
    "project_create_schema",
    "project_create_request_schema",
    "project_run_checks_schema",
    "project_select_schema",
    "project_update_descriptions_schema",
    "research_plan_schema",
    "research_brief_schema",
    "qa_answer_schema",
    "analyze_plan_schema",
    "self_review_schema",
    "target_analysis_schema",

    # validation helpers
    "validate_instance",
    "validate_instance_safe",
    "validate_schema",
    "validate_payload",

    # convenience validators
    "validate_research_plan",
    "validate_research_plan_tuple",
    "validate_analyze_plan",
    "validate_analyze_plan_tuple",
    "validate_analyze_plan_raise",

    # domain-specific
    "validate_targets_envelope",
]
